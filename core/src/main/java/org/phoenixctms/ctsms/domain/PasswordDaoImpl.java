// Generated by: hibernate/SpringHibernateDaoImpl.vsl in andromda-spring-cartridge.
// license-header java merge-point
/**
 * This is only generated once! It will never be overwritten.
 * You can (and have to!) safely modify it by hand.
 */
package org.phoenixctms.ctsms.domain;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Date;

import org.hibernate.criterion.DetachedCriteria;
import org.hibernate.criterion.Order;
import org.hibernate.criterion.Projections;
import org.hibernate.criterion.Restrictions;
import org.hibernate.criterion.Subqueries;
import org.phoenixctms.ctsms.enumeration.AuthenticationType;
import org.phoenixctms.ctsms.enumeration.VariablePeriod;
import org.phoenixctms.ctsms.query.CriteriaUtil;
import org.phoenixctms.ctsms.query.SubCriteriaMap;
import org.phoenixctms.ctsms.util.CommonUtil;
import org.phoenixctms.ctsms.util.L10nUtil;
import org.phoenixctms.ctsms.util.L10nUtil.Locales;
import org.phoenixctms.ctsms.util.ServiceUtil;
import org.phoenixctms.ctsms.vo.PSFVO;
import org.phoenixctms.ctsms.vo.PasswordInVO;
import org.phoenixctms.ctsms.vo.PasswordOutVO;

/**
 * @see Password
 */
public class PasswordDaoImpl
		extends PasswordDaoBase {

	private org.hibernate.Criteria createPasswordCriteria(String alias) {
		org.hibernate.Criteria passwordCriteria;
		if (alias != null && alias.length() > 0) {
			passwordCriteria = this.getSession().createCriteria(Password.class, alias);
		} else {
			passwordCriteria = this.getSession().createCriteria(Password.class);
		}
		return passwordCriteria;
	}

	@Override
	protected Collection<Password> handleFindExpiring(Date today,
			Long departmentId, AuthenticationType authMethod, VariablePeriod reminderPeriod,
			Long reminderPeriodDays, Boolean notify, boolean includeAlreadyPassed, PSFVO psf) throws Exception {
		org.hibernate.Criteria passwordCriteria = createPasswordCriteria("password0");
		SubCriteriaMap criteriaMap = new SubCriteriaMap(Password.class, passwordCriteria);
		if (departmentId != null) {
			criteriaMap.createCriteria("user").add(Restrictions.eq("department.id", departmentId.longValue()));
		}
		if (authMethod != null) {
			criteriaMap.createCriteria("user").add(Restrictions.eq("authMethod", authMethod));
		}
		DetachedCriteria subQuery = DetachedCriteria.forClass(PasswordImpl.class, "password1"); // IMPL!!!!
		subQuery.add(Restrictions.eqProperty("password1.user", "password0.user"));
		subQuery.setProjection(Projections.max("id"));
		passwordCriteria.add(Subqueries.propertyEq("id", subQuery));
		passwordCriteria.add(Restrictions.eq("expires", true)); // performance only...
		if (notify != null) {
			passwordCriteria.add(Restrictions.eq("prolongable", notify.booleanValue())); // performance only...
		}
		if (psf != null) {
			PSFVO sorterFilter = new PSFVO();
			sorterFilter.setFilters(psf.getFilters());
			sorterFilter.setFilterTimeZone(psf.getFilterTimeZone());
			sorterFilter.setSortField(psf.getSortField());
			sorterFilter.setSortOrder(psf.getSortOrder());
			CriteriaUtil.applyPSFVO(criteriaMap, sorterFilter);
		}
		ArrayList<Password> resultSet = CriteriaUtil.listExpirations(passwordCriteria, today, notify, includeAlreadyPassed, null, null, reminderPeriod, reminderPeriodDays);
		return CriteriaUtil.applyPVO(resultSet, psf, false); // no dupes by default
	}

	/**
	 * @inheritDoc
	 */
	@Override
	protected Password handleFindLastPassword(Long userId) {
		org.hibernate.Criteria passwordCriteria = createPasswordCriteria(null);
		if (userId != null) {
			passwordCriteria.add(Restrictions.eq("user.id", userId.longValue()));
		}
		passwordCriteria.addOrder(Order.desc("id"));
		passwordCriteria.setMaxResults(1);
		return (Password) passwordCriteria.uniqueResult();
	}

	@Override
	protected long handleGetCount(Long userId) throws Exception {
		org.hibernate.Criteria passwordCriteria = createPasswordCriteria(null);
		passwordCriteria.add(Restrictions.eq("user.id", userId.longValue()));
		return (Long) passwordCriteria.setProjection(Projections.rowCount()).uniqueResult();
	}

	/**
	 * Retrieves the entity object that is associated with the specified value object
	 * from the object store. If no such entity object exists in the object store,
	 * a new, blank entity is created
	 */
	private Password loadPasswordFromPasswordInVO(PasswordInVO passwordInVO) {
		throw new UnsupportedOperationException("org.phoenixctms.ctsms.domain.loadPasswordFromPasswordInVO(PasswordInVO) not yet implemented.");
	}

	/**
	 * Retrieves the entity object that is associated with the specified value object
	 * from the object store. If no such entity object exists in the object store,
	 * a new, blank entity is created
	 */
	private Password loadPasswordFromPasswordOutVO(PasswordOutVO passwordOutVO) {
		throw new UnsupportedOperationException("org.phoenixctms.ctsms.domain.loadPasswordFromPasswordOutVO(PasswordOutVO) not yet implemented.");
	}

	/**
	 * @inheritDoc
	 */
	@Override
	public Password passwordInVOToEntity(PasswordInVO passwordInVO) {
		Password entity = Password.Factory.newInstance();
		this.passwordInVOToEntity(passwordInVO, entity, true);
		return entity;
	}

	/**
	 * @inheritDoc
	 */
	@Override
	public void passwordInVOToEntity(
			PasswordInVO source,
			Password target,
			boolean copyIfNull) {
		super.passwordInVOToEntity(source, target, copyIfNull);
	}

	/**
	 * @inheritDoc
	 */
	@Override
	public Password passwordOutVOToEntity(PasswordOutVO passwordOutVO) {
		Password entity = this.loadPasswordFromPasswordOutVO(passwordOutVO);
		this.passwordOutVOToEntity(passwordOutVO, entity, true);
		return entity;
	}

	/**
	 * @inheritDoc
	 */
	@Override
	public void passwordOutVOToEntity(
			PasswordOutVO source,
			Password target,
			boolean copyIfNull) {
		super.passwordOutVOToEntity(source, target, copyIfNull);
	}

	/**
	 * @inheritDoc
	 */
	@Override
	public PasswordInVO toPasswordInVO(final Password entity) {
		return super.toPasswordInVO(entity);
	}

	/**
	 * @inheritDoc
	 */
	@Override
	public void toPasswordInVO(
			Password source,
			PasswordInVO target) {
		super.toPasswordInVO(source, target);
	}

	/**
	 * @inheritDoc
	 */
	@Override
	public PasswordOutVO toPasswordOutVO(final Password entity) {
		return super.toPasswordOutVO(entity);
	}

	/**
	 * @inheritDoc
	 */
	@Override
	public void toPasswordOutVO(
			Password source,
			PasswordOutVO target) {
		super.toPasswordOutVO(source, target);
		User user = source.getUser();
		if (user != null) {
			target.setInheritedUser(this.getUserDao().toUserOutVO(user));
			CommonUtil.copyInheritedUserToOut(this.getUserDao().toUserInheritedVO(user), target.getInheritedUser());
		}
		target.setValidityPeriod(L10nUtil.createVariablePeriodVO(Locales.USER, source.getValidityPeriod()));
		if (target.isExpires()) {
			target.setExpiration(ServiceUtil.getLogonExpirationDate(source));
		}
		target.setOtpType(L10nUtil.createOTPAuthenticatorTypeVO(Locales.USER, source.getOtpType()));
		target.setHasOtpSecret(source.getEncryptedOtpSecret() != null ? source.getEncryptedOtpSecret().length > 0 : false);
	}
}